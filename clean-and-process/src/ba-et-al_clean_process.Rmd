---
title: "Replicate Ba et al. 2021 - Cleaning and Processing"
output: pdf_document
---

```{r, include = F}
library(knitr)
opts_chunk$set(message = F, echo = F, warning = F)

library(here)
source(here("functions.R"))

library(tidyr)
library(readr)
library(dplyr)
library(purrr)
library(stringr)
library(lubridate)
library(data.table)
```

```{r}
3661994
load(here("clean-and-process", "src", "stops_merged_final.rds"))
a <- stops_merged_final %>% select(time, date, hour, stop_officer_id, start_time, end_time, shift_id)
b <- a %>% filter(is.na(stop_officer_id)) %>% arrange(shift_id)
c <- stops_merged_final %>% filter(shift_id == "1000768")
d <- stops_merged_final %>% distinct()
`%.%` <- paste0
read_path <- paste("clean-and-process", "output", sep = "/")

officers <- my_read_csv(here(read_path, "cleaned_officers.csv"))
assignments <- my_read_csv(here(read_path, "cleaned_assignments.csv"))
stops <- my_read_csv(here(read_path, "cleaned_stops.csv"))

setDT(officers)
setDT(assignments)
setDT(stops)
```

```{r}
# merge officer characteristics
officer_assignments <- assignments[officers[,.(officer_id,
                                              birth_year,
                                              officer_race,
                                              officer_gender,
                                              spanish)],
                                  on = 'officer_id']

# drop officers for whom no assignments were found
officer_assignments <- officer_assignments[!is.na(date),]

# drop all but POLICE OFFICER
rank_fltr <- officer_assignments[rank == 'POLICE OFFICER',]

# drop all officers except black, Hispanic, and white
race_fltr <- officer_assignments[
    officer_race %in% ('officer_' %.% c('black', 'white', 'hisp')),]

officer_assignments_fltr <-
    officer_assignments %>%
    filter(officer_race %in% c(paste0("officer_", c("white", "black", "hisp"))),
           rank == "POLICE OFFICER")

# Find officers which had no shifts and any shifts which had no officers
anti_join_assignments <- anti_join(assignments, officers, by = "officer_id")
anti_join_officers <- anti_join(officers, assignments, by = "officer_id")
```

## Merging Officers To Their Shift Assignments

* Number of officer shift assignments: `r nrow(officer_assignments)`
* Number of unique officers: `r length(unique(officer_assignments$officer_id))`
* Number of non-matching assignments: `r nrow(anti_join_assignments)`
    * Percentage of assignments which don't match: `r nrow(anti_join_assignments) / nrow(assignments) * 100`%
* Number of non-matching officers: `r nrow(anti_join_officers)`
    * Percentage of officers which don't match: `r nrow(anti_join_officers) / nrow(officers) * 100`%  
    
## Filtering

### Race

> "We restrict analysis to patrol assignments in which Black, Hispanic, or White officers serve. Asian/Pacific Islander and Native American/Alaskan Native officers are not examined due to small sample sizes." page 7 of Appendix Section S1.4 in Ba et al. 2021.

* Number of officer shift assignments: `r nrow(race_fltr)`
    * Shifts dropped: `r nrow(officer_assignments) - nrow(race_fltr)`
    * Percentage reduction: `r (nrow(officer_assignments) - nrow(race_fltr)) / nrow(officer_assignments) * 100`%
* Number of unique officers: `r length(unique(race_fltr$officer_id))`
    * Officers dropped: `r length(unique(officer_assignments$officer_id)) - length(unique(race_fltr$officer_id))`
    * Percentage reduction: `r (length(unique(officer_assignments$officer_id)) - length(unique(race_fltr$officer_id))) / length(unique(officer_assignments$officer_id)) * 100`%
    
### Rank

> "Finally, we drop officers at ranks other than 'police officer.' This step eliminates police sergeants, who serve in 8% of beat assignments but make very few stops and arrests, as well as legal officers, helicopter pilots, explosives technicians, and canine handlers." page 7 of Appendix Section S1.4 in Ba et al. 2021.

* Number of officer shift assignments: `r nrow(rank_fltr)`
    * Shifts dropped: `r nrow(officer_assignments) - nrow(rank_fltr)`
    * Percentage reduction: `r (nrow(officer_assignments) - nrow(rank_fltr)) / nrow(officer_assignments) * 100`%
* Number of unique officers: `r length(unique(rank_fltr$officer_id))`
    * Officers dropped: `r length(unique(officer_assignments$officer_id)) - length(unique(rank_fltr$officer_id))`
    * Percentage reduction: `r (length(unique(officer_assignments$officer_id)) - length(unique(rank_fltr$officer_id))) / length(unique(officer_assignments$officer_id)) * 100`%
    
### Totals

* Note the numbers above won't completely add up to the numbers below because of intersections.
* **Number of officer shift assignments**: `r nrow(officer_assignments_fltr)`
    * Shifts dropped: `r nrow(officer_assignments) - nrow(officer_assignments_fltr)`
    * Percentage reduction: `r (nrow(officer_assignments) - nrow(officer_assignments_fltr)) / nrow(officer_assignments) * 100`%
* **Number of unique officers**: `r length(unique(officer_assignments_fltr$officer_id))`
    * Officers dropped: `r length(unique(officer_assignments$officer_id)) - length(unique(officer_assignments_fltr$officer_id))`
    * Percentage reduction: `r (length(unique(officer_assignments$officer_id)) - length(unique(officer_assignments_fltr$officer_id))) / length(unique(officer_assignments$officer_id)) * 100`%

## Creating Stop Outcomes

```{r}
# sort for merging
setkey(officer_assignments_fltr, officer_id, date)
setkey(stops, officer_id, date)

# subset to stops occurring during recorded shift

## step 1: match officer_id, match stop date to date of shift start
stops.merged <- stops[officer_assignments_fltr]
stops.merged[, month := i.month]
stops.merged <- stops.merged[, !"i.month", with = F]

## drop if not during shift (keep those shifts with no stops)
stops.merged <-
    stops.merged[  
    is.na(hour) | between(hour, floor(start_time), ceiling(end_time)),]

## step 2: match officer_id, deal with stops past midnight on overnight shifts
####  Find overnight shifts, fix start and end time, increment date by one day
assignments.nextday <- officer_assignments_fltr[end_time > 24]
assignments.nextday[, new_start_time := 0]
assignments.nextday[, new_end_time := end_time - 24]
assignments.nextday[, date_next := date]
day(assignments.nextday$date_next) <- day(assignments.nextday$date_next) + 1

## Match officer_id and stop date to the new start date of the overnight shift
setkey(assignments.nextday, officer_id, date_next)
stops.merged.nextday <-
    stops[assignments.nextday,
          ,
          on = c(officer_id = 'officer_id', date = 'date_next')]

## drop if not during shift (keep those shifts with no stops)
stops.merged.nextday <-
    stops.merged.nextday[
        is.na(hour) |
            between(hour, floor(new_start_time), ceiling(new_end_time)),]

## Revert back to the normal date
drop_cols <- c("i.date", "new_end_time", "new_start_time", "i.month")
stops.merged.nextday[, `:=`(date = i.date, month = i.month)]
stops.merged.nextday <- stops.merged.nextday[, !drop_cols, with = F]

## merge same-day stops with next-day stops on overnight shifts
stops_merged_final <-
    rbind(stops.merged, stops.merged.nextday) %>%
    distinct() %>%
    group_by(shift_id) %>%
    filter((n() > 1 & !is.na(stop_officer_id)) | n() == 1) %>%
    ungroup()
```

1. Right join stops and assignments using officer_id and date. I.e. keep every assignment and only stops which occurred during the start date of the shift.
2. Keep any stops which occurred during the hours of the shift.
    * Round the stop time to the lowest hour.
    * Round the shift start time to the lowest hour.
    * Round the shift end time to the highest hour.
3. Right join stops and assignments using officer_id and date (incremented by one day). This captures stops which occurred the **following day** during an overnight shift.
4. Keep any stops which occurred during the hours of the shift using the same logic as in step 2.
5. Merge the data sets (stops merged by date and stops merged by the next day) by row..........................
