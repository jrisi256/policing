---
title: "Replicate Ba et al. 2021 - Cleaning and Processing"
output: pdf_document
---

```{r, include = F}
library(knitr)
opts_chunk$set(message = F, echo = F, warning = F)

library(here)
source(here("functions.R"))

library(tidyr)
library(readr)
library(dplyr)
library(purrr)
library(stringr)
library(ggplot2)
library(lubridate)
library(data.table)

`%.%` <- paste0
path <- paste("clean-and-process", "output", sep = "/")

officer_assignments <- my_read_csv(here(path, "officers_assignments_ba.csv"))
stops <- my_read_csv(here(path, "cleaned-stops.csv"))

setDT(officer_assignments)
setDT(stops)
```

```{r}
# sort for merging
setkey(officer_assignments, officer_id, date)
setkey(stops, officer_id, date)

# subset to stops occurring during recorded shift

## step 1: match officer_id, match stop date to date of shift start
stops.merged <- stops[officer_assignments]
stops.merged[, month := i.month]
stops.merged <- stops.merged[, !"i.month", with = F]

## drop if not during shift (keep those shifts with no stops)
stops.merged <-
    stops.merged[
    is.na(hour) | between(hour, floor(start_time), ceiling(end_time)),]

## step 2: match officer_id, deal with stops past midnight on overnight shifts
####  Find overnight shifts, fix start and end time, increment date by one day
assignments.nextday <- officer_assignments[end_time > 24]
assignments.nextday[, new_start_time := 0]
assignments.nextday[, new_end_time := end_time - 24]
assignments.nextday[, date_next := date]
day(assignments.nextday$date_next) <- day(assignments.nextday$date_next) + 1

## Match officer_id and stop date to the new start date of the overnight shift
setkey(assignments.nextday, officer_id, date_next)
stops.merged.nextday <-
    stops[assignments.nextday,
          ,
          on = c(officer_id = 'officer_id', date = 'date_next')]

## drop if not during shift (keep those shifts with no stops)
stops.merged.nextday <-
    stops.merged.nextday[
        is.na(hour) |
            between(hour, floor(new_start_time), ceiling(new_end_time)),]

## Revert back to the normal date
drop_cols <- c("i.date", "new_end_time", "new_start_time", "i.month")
stops.merged.nextday[, `:=`(date = i.date, month = i.month)]
stops.merged.nextday <- stops.merged.nextday[, !drop_cols, with = F]

## merge same-day stops with next-day stops on overnight shifts
stops_merged_final <-
    rbind(stops.merged, stops.merged.nextday) %>%
    distinct() %>%
    group_by(shift_id) %>%
    filter((n() > 1 & !is.na(stop_officer_id)) | n() == 1) %>%
    ungroup()
setDT(stops_merged_final)

write_csv(stops_merged_final,
          here(path, "stops_officers_assignments_ba_max.csv"))

# Find shift assignments with missing start/end times that matched with a stop
missing_times_stop <-
    stops_merged_final %>%
    filter((is.na(start_time) | is.na(end_time)) & !is.na(stop_officer_id))

# Find stops which matched with multiple shifts
duplicate_stops <-
    stops_merged_final %>%
    group_by(stop_officer_id) %>%
    filter(!is.na(stop_officer_id) & n() > 1) %>%
    ungroup()
```

## Merge stops to officer shift assignments

### Merge process - Ba et al. 2021

> "For stops, arrests, and uses of force, we drop all events that occur outside of the reported patrol start/stop times, eliminating off-duty activity." page 8 of Appendix Section S1.5 in Ba et al. 2021.

1. Right join stops and officer assignments using officer_id and date. I.e. keep every assignment and only stops which occurred during the start date of the shift.
2. Keep any stops which occurred during the hours of the shift.
    * Round the stop time to the lowest hour.
    * Round the shift start time to the lowest hour.
    * Round the shift end time to the highest hour.
3. Right join stops and assignments using officer_id and date (incremented by one day). This captures stops which occurred the **following day** during an overnight shift.
4. Keep any stops which occurred during the hours of the shift using the same logic as in step 2.
5. Merge the data sets (stops merged by date and stops merged by the next day) by row. 
    * Keep only distinct entries. Shift assignments which had no stops will have duplicate entries since they will appear as having had no stops on the focal day **and** the next day (since we also check the next day due to overnight shifts).
    * Filter out any shift assignments which matched one date but not the other. For example, a non-overnight shift will obviously not match with any stops the following day. As a result, there will be an entry for that shift assignment with no stops associated with it. However, there will be other entries for that shift assignment with the appropriate stops. As a result, the shift assignment entry in question is erroneous.

### Merge results - Ba et al. 2021

* Number of resulting rows: `r nrow(stops_merged_final)`
* Number of stops which occurred during a shift: `r length(unique(stops_merged_final$stop_officer_id))`
    * Percentage of stops (`r nrow(stops)`): `r length(unique(stops_merged_final$stop_officer_id)) / nrow(stops) * 100`%
* Number of unique officers who had at least one stop during a shift: `r length(unique(stops_merged_final$officer_id))`
    * Percentage of officers: `r length(unique(stops_merged_final$officer_id)) / length(unique(officer_assignments$officer_id)) * 100`%
* Number of shift assignments retained: `r length(unique(stops_merged_final$shift_id))`
    * Percentage of shift assignments: `r length(unique(stops_merged_final$shift_id)) / nrow(officer_assignments) * 100`%
    * Why aren't all shift assignments retained? Ba et al. (2021) have it so that any shift assignment which had a stop on the same day **but** did not occur during the shift times is counted as missing and not retained.
* `r length(unique(missing_times_stop$shift_id))` shift assignments matched with at least one stop **without having** a start time and an end time.
    * This represents `r 100 * length(unique(missing_times_stop$shift_id)) / nrow(officer_assignments)`% of all shift assignments.
    * `r length(unique(missing_times_stop$stop_officer_id))` stops are affected or `r length(unique(missing_times_stop$stop_officer_id)) / nrow(stops) * 100`% of all stops.
    * Ba et al. (2021) implicitly assume the matched stops occurred during these shifts. The **date** matches at the very least (i.e. the date of the stop and the date of the shift).
* There are `r length(unique(duplicate_stops$stop_officer_id))` stops which match to more than one shift assignment.
    * These **duplicate** stops represent `r 100 * length(unique(duplicate_stops$stop_officer_id)) / nrow(stops)`% of all stops (`r nrow(stops)`).
    * `r length(unique(duplicate_stops$shift_id))` shift assignments are affected or `r 100 * length(unique(duplicate_stops$shift_id)) / nrow(officer_assignments)`% of all shift assignments.
    * In total, there are `r nrow(duplicate_stops)` **duplicate stop-shift observations** representing `r nrow(duplicate_stops) / nrow(stops_merged_final) * 100`% of all stop-shift observations.
    * How can a stop match to more than one shift assignment?
        * The officer in question could have had overlapping shift assignments, and the stop occurred during the intersection of their shifts.
        * One of the shifts had a missing start time or end time, and the stop matched with that shift (in addition to matching with at least one another shift assignment).

```{r}
stops_join <- stops %>% select(-date, -month)

stops_shift_assignments <-
    stops_join[officer_assignments,
               on = .(officer_id, time >= start_datetime, time <= end_datetime)] %>%
    rename(start_datetime = time, end_datetime = time.1) %>%
    left_join(select(stops, time, stop_officer_id), by = "stop_officer_id")

# Find stops which matched with multiple shifts
duplicate_stops_risi <-
    stops_shift_assignments %>%
    group_by(stop_officer_id) %>%
    filter(!is.na(stop_officer_id) & n() > 1) %>%
    ungroup()

# Remove duplicates
stops_shift_assignments <-
    stops_shift_assignments %>%
    group_by(stop_officer_id) %>%
    filter(is.na(stop_officer_id) | n() <= 1) %>%
    ungroup()

write_csv(stops_shift_assignments,
          here(path, "stops_officers_assignments_ba_min.csv"))
```

### Merge process - Risi

1. Conduct a right non-equi join on stops and officer assignments using officer_id, time of the stop, the start time of the shift, and the end time of the shift. I.e. Keep every shift assignment and keep those stops which occurred exactly between the start time and end time for a particular shift.
2. **Differences from Ba et al. 2021**
    * Any shift with a missing start time and end time will not match with any stops. Ba et al. 2021 will match a shift with a missing start time and end time with any stop that occurred on the same day(s) as the shift.
    * The stop must have occurred exactly between the start time and end time of the shift. Ba et al. 2021 use rounding to create a window of time around the shift start and end times in which a stop may have occurred and would still count as happening during the shift.
    * If a shift assignment has a stop which occurs the same day, but the stop does not occur during the shift times, the shift is recorded as having no stops rather being recorded as *missing*.
    * Any stops which are matched to multiple shift assignment are dropped. **All duplicate entries** are dropped.

### Merge results - Risi

* Number of resulting rows: `r nrow(stops_shift_assignments)`
* Number of stops which occurred during a shift: `r length(unique(stops_shift_assignments$stop_officer_id))`
    * Percentage of stops (`r nrow(stops)`): `r length(unique(stops_shift_assignments$stop_officer_id)) / nrow(stops) * 100`%
    * Number of fewer stops matched than Ba et al. 2021: `r length(unique(stops_merged_final$stop_officer_id)) - length(unique(stops_shift_assignments$stop_officer_id))`
    * Percent reduction from Ba et al. 2021 (`r length(unique(stops_merged_final$stop_officer_id))`): `r (length(unique(stops_merged_final$stop_officer_id)) - length(unique(stops_shift_assignments$stop_officer_id))) / length(unique(stops_merged_final$stop_officer_id)) * 100`%
* Number of unique officers who had at least one stop during a shift: `r length(unique(stops_shift_assignments$officer_id))`
    * Percentage of officers: `r length(unique(stops_shift_assignments$officer_id)) / length(unique(officer_assignments$officer_id)) * 100`%
* There are `r length(unique(duplicate_stops_risi$stop_officer_id))` stops which match to more than one shift assignment.
    * These **duplicate** stops represent `r 100 * length(unique(duplicate_stops_risi$stop_officer_id)) / nrow(stops)`% of all stops (`r nrow(stops)`).
    * `r length(unique(duplicate_stops_risi$shift_id))` shift assignments are affected or `r 100 * length(unique(duplicate_stops_risi$shift_id)) / nrow(officer_assignments)`% of all shift assignments.
    * In total, there are `r nrow(duplicate_stops_risi)` **duplicate stop-shift observations** representing `r nrow(duplicate_stops_risi) / nrow(stops_merged_final) * 100`% of all stop-shift observations.
    * As noted above, **all these entries are dropped**.
    * How can a stop match to more than one shift assignment?
        * The officer in question could have had overlapping shift assignments, and the stop occurred during the intersection of their shifts.
        
## Final notes

* Shift assignments which are missing their start time and end time could potentially be imputed which is explored elsewhere. The number of records affected is so small though it is not currently a priority.
* Similarly efforts could be made to de-duplicate stops and determine the correct shift assignment they should be matched to. This is explored elsewhere, but ultimately the number of records affected is so small it is not currently a priority.
