---
title: "Replicate Ba et al. 2021, Cleaning Police Stops"
output: pdf_document
---

```{r, include = F}
library(knitr)
opts_chunk$set(message = F, echo = F)

library(here)
library(dplyr)
library(tidyr)
library(readr)
library(lubridate)
library(data.table)
```

```{r}
assignments_ba_dt <-
  fread(here("0-clean-data", "output", "officer_assignments-ba.csv")) %>%
  mutate(date = ymd(date))

stops_dt <-
  fread(here("0-clean-data", "input", "bocar-ba_data", "stops.csv")) %>%
  select(-civilian_race_short, -month) %>%
  mutate(date = ymd(date),
         stop_officer_id = row_number())
```

## Officer stops

* **stop_id**: Unique identifier for each stop.
* **time**: Time of stop.
* **date**: Date of stop.
* **district**: Police district where the stop took place.
* **po_first**: Was the focal officer the first to respond to the scene?
* **stop_type**: What was the type of the stop?
* **contact_type**: Collapsed version of **stop_type** (less categories).
* **civ.race**: Race of the civilian.
* **civ.gender**: Sex of the civilian.
* **civ.age**: Age of the civilian at the time of the stop.
* **lat**: Latitude of the stop.
* **lon**: Longitude of the stop.
* **officer_id**: Unique identifier for the officer.
* **month**: Month of stop. **Dropped as it can be recreated**.
* **civilian_race_short**: Collapsed version of **civ.race** (less categories). **Dropped as it can be recreated**.
* **hour**: Hour of the day when the stop took place.
* **stop_officer_id**: Unique identifier for each entry.
* The unit of analysis is a unique officer involved in a stop. Each row can be uniquely identified by **officer_id** and **stop_id** or by **stop_officer_id**.
* Each stop involves only one civilian, but they can involve multiple officers. It is possible multiple stops are all a part of one larger incident involving multiple civilians. This can be investigated by examining stops that took place in the same location at the same time involving the same officers.
* **Number of stops**: `r nrow(stops_dt)`
* **Number of unique stops**: `r length(unique(stops_dt$stop_id))`

## Ba et al. 2021 Replication - Merging stops to officer assignments

```{r}
# Set the key to make the joining go faster
setkey(stops_dt, officer_id, date)
setkey(assignments_ba_dt, officer_id, date)

# Right join officer shift assignments with stops
stops_merged <- stops_dt[assignments_ba_dt,]

# Drop the stop if it did not occur during the shift
stops_merged <-
    stops_merged[between(hour, floor(start_time), ceiling(end_time)),]

# Deal with stops past midnight on overnight shifts
## Find overnight shifts, fix start and end time, increment date one day forward
assignments_nextday <- assignments_ba_dt[end_time > 24]
assignments_nextday[, new_start_time := 0]
assignments_nextday[, new_end_time := end_time - 24]
assignments_nextday[, date_nextday := date]
day(assignments_nextday$date_nextday) <-
  day(assignments_nextday$date_nextday) + 1
setkey(assignments_nextday, officer_id, date_nextday)

# Right join officer shift assignments with stops
stops_merged_nextday <-
  stops_dt[assignments_nextday,,
           on = c(officer_id = 'officer_id', date = 'date_nextday')]

# Drop the stop if it did not occur during the shift
stops_merged_nextday <-
  stops_merged_nextday[between(hour, floor(new_start_time), ceiling(new_end_time)),]

# Revert back to the normal date
stops_merged_nextday[, date := i.date]
stops_merged_nextday[, c("i.date", "new_end_time", "new_start_time") := NULL]

# Merge same-day stops with next-day stops on overnight shifts.
# Then add shift assignments which had no stops.
stops_merged_joined <-
    rbind(stops_merged, stops_merged_nextday) %>%
    full_join(assignments_ba_dt, by = colnames(assignments_ba_dt))

rm(stops_merged, stops_merged_nextday)
```

Ba et al. (2021) are only concerned with stops which occur during an officer's shift so their data cleaning and merging process reflects that.

1. Right join stops and assignments using officer_id and date. I.e. keep every assignment and only stops which occurred during the start date of the shift.
2. Keep any stops which occurred during the hours of the shift.
    * Round the stop time to the lowest hour.
    * Round the shift start time to the lowest hour.
    * Round the shift end time to the highest hour.
3. Right join stops and assignments using officer_id and date (incremented by one day). This captures stops which occurred the **following day** during an overnight shift.
4. Filter out all stops which do not occur during the hours of the shift using the same logic as in step 2.
5. Merge the data sets (stops merged by date and stops merged by the next day) by row, and join them back with the shift assignment data set to capture any shift assignments which did not have a stop associated with them.

* Number of resulting stop-shift assignment observations: `r nrow(stops_merged_joined)`
* Number of shift assignments: `r length(unique(stops_merged_joined$shift_id))`
* Number of stop-officer observations: `r length(unique(stops_merged_joined$stop_officer_id))`
    * Percentage of stop-officer observations occurring during an officer's shift: `r 100 * length(unique(stops_merged_joined$stop_officer_id)) / nrow(stops_dt)`%.
* Number of officers who made stops during their shift: `r length(unique(stops_merged_joined$officer_id))`
    * Percentage of officers who made at least one stop during **any** of their shifts: `r 100 * length(unique(stops_merged_joined$officer_id)) / length(unique(assignments_ba_dt$officer_id))`%

## Changing Ba et al. 2021's data cleaning and merging Processes

### Missing Starting and Ending Shift Times

```{r}
missing_shift_times <-
    assignments_ba_dt %>%
    filter(is.na(start_time) | is.na(end_time))

missing_shift_times_stop <-
    stops_merged_joined %>%
    filter((is.na(start_time) | is.na(end_time)) & !is.na(stop_officer_id))
```

* Of the `r nrow(assignments_ba_dt)` shift assignments, `r nrow(missing_shift_times)` are missing their start time and end time.
    * This represents `r 100 * nrow(missing_shift_times) / nrow(assignments_ba_dt)`% of all shift assignments.
* `r length(unique(missing_shift_times_stop$shift_id))` shift assignments matched with at least one stop **without having** a start time and an end time.
    * This represents `r 100 * length(unique(missing_shift_times_stop$shift_id)) / nrow(assignments_ba_dt)`% of all shift assignments.
* Ba et al. 2021 implicitly assume the matched stops occurred during these shifts which may or may not be plausible. The **date** matches at the very least (i.e. the date of the stop and the date of the shift). One can compare the same beat assignments during the same days of the week to see how regular shift start times and end times are. Assuming regularity, the start times and end times can be imputed. A more conservative solution would be to just drop all shift assignments which do not have a start time and an end time.

### Duplicate Entries

```{r}
duplicates <-
    stops_merged_joined %>%
    group_by(stop_officer_id) %>%
    filter(!is.na(stop_officer_id) & n() > 1) %>%
    ungroup()

remove_na_dupes <-
    duplicates %>%
    filter(!is.na(start_time) & !is.na(end_time)) %>%
    group_by(stop_officer_id) %>%
    filter(n() > 1) %>%
    ungroup() %>%
    mutate(duplicate = 1)

# Remove duplicate stops to get an accurate count of the number of stops per officer
officer_count_stops <-
    remove_na_dupes %>%
    distinct(stop_officer_id, .keep_all = T) %>%
    count(officer_id)
```

* There are `r length(unique(duplicates$stop_officer_id))` stops which match to more than one shift assignment.
    * These **duplicate** stops represent `r 100 * length(unique(duplicates$stop_officer_id)) / nrow(stops_dt)`% of all stops (`r nrow(stops_dt)`).
    * Overall, `r nrow(duplicates)` records are affected which represents `r 100 * nrow(duplicates) / nrow(stops_merged_joined)`% of all stop-shift assignment records (`r nrow(stops_merged_joined)`).
* How can a stop match to more than one shift assignment?
    * The officer in question could have had overlapping shift assignments, and the stop occurred during the intersection of their shifts.
    * One of the shifts had a missing start time or end time, and the stop matched with that shift (in addition to matching with at least one another shift assignment).
    
**Potential Solutions**  

* One easy fix which immediately comes to mind is to remove all stop-shift assignments where the start time and end time are missing. This doesn't eliminate all duplicates, but it does eliminate most of them. This issue may also be partially fixed upstream when I implement the solution for dealing with missing start times and end times.
    * Number of duplicate stops after removing shift assignments with missing start and end times: `r length(unique(remove_na_dupes$stop_officer_id))` 
    * Percentage reduction after removing shift assignments with a missing start and end time: `r 100 * (length(unique(duplicates$stop_officer_id)) - length(unique(remove_na_dupes$stop_officer_id))) / length(unique(duplicates$stop_officer_id))`%. (Going from `r length(unique(duplicates$stop_officer_id))` to `r length(unique(remove_na_dupes$stop_officer_id))`)
* What should be done about the remaining duplicate entries? Well the stop did occur during both shifts if we are to believe the officer worked on overlapping shifts. It is accurate to say a stop occurred during both shifts. Care will just need to be taken when aggregating the number of stops to an officer across shifts to avoid over counting (i.e. counting the same stop twice).

```{r}
stops_flag <-
    stops_merged_joined %>%
    mutate(stopCount = if_else(is.na(stop_officer_id), 0 , 1))

stops_total <-
    stops_flag %>%
    count(shift_id, wt = stopCount) %>%
    rename(stops_n_total = n)

stops_contact <-
    stops_flag %>%
    count(shift_id, contact_type, wt = stopCount) %>%
    filter(!is.na(contact_type)) %>%
    mutate(contact_type = paste0("stops_n_", contact_type)) %>%
    pivot_wider(id_cols = shift_id,
                names_from = contact_type,
                values_from = n,
                values_fill = 0)

stops_civrace <-
    stops_flag %>%
    count(shift_id, civ.race, wt = stopCount) %>%
    filter(!is.na(civ.race)) %>%
    mutate(civ.race = tolower(civ.race)) %>%
    mutate(civ.race = case_when(civ.race == "asian/pacific islander" ~ "aapi",
                                civ.race == "amer ind/alaskan native" ~ "aian",
                                T ~ civ.race)) %>%
    mutate(civ.race = paste0("stops_n_civilian_", civ.race)) %>%
    pivot_wider(id_cols = shift_id,
                names_from = civ.race,
                values_from = n,
                values_fill = 0)

assignments_outcomes <-
    assignments_ba_dt %>%
    full_join(stops_total, by = "shift_id") %>%
    full_join(stops_civrace, by = "shift_id") %>%
    full_join(stops_contact, by = "shift_id") %>%
    mutate(across(matches("stops_n"), ~replace_na(.x, 0)))

# Read in Ba et al. 2021 pure replication
ba_assignments_outcomes <-
    read_csv(here("0-clean-data", "output", "stops-outcomes_ba.csv")) %>%
    filter(is.na(stops_n_total))

write_csv(stops_merged_joined,
          here("0-clean-data", "output", "stops-assignments_ba-joe.csv"))

write_csv(assignments_outcomes,
          here("0-clean-data", "output", "stops-outcomes_ba-joe.csv"))
```

## Create outcomes

Aggregate across all shift assignments:  

* The total number of stops for that shift.
* The total number of stops by contact type for that shift.
* The total number of stops by civilian race for that shift.
* **NOTE**: There are `r nrow(ba_assignments_outcomes)` shift assignments which have missing values for the number of stops. In the original Ba et al. 2021 paper, these shift assignments had stops which took place during the same day of the shift but did not occur during the actual shift. It's unclear why Ba et al. 2021 consider these shift assignments as **missing** the number of stops rather than having **zero** stops. In any case, I consider these shift assignments to have zero stops.
    * Percentage of shift assignments missing the number of stops: `r 100 * nrow(ba_assignments_outcomes) / nrow(assignments_ba_dt)`%.
