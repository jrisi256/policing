---
title: "Replicate Ba et al. 2021, Cleaning Police Stops"
output: pdf_document
---

```{r, include = F}
library(knitr)
opts_chunk$set(message = F, echo = F)

library(here)
library(dplyr)
library(tidyr)
library(readr)
library(lubridate)
library(data.table)
```

```{r}
assignments_ba_dt <-
  fread(here("0-clean-data", "output", "officer_assignments-ba.csv")) %>%
  mutate(date = ymd(date))

stops_dt <-
  fread(here("0-clean-data", "input", "bocar-ba_data", "stops.csv")) %>%
  select(-civilian_race_short, -month) %>%
  mutate(date = ymd(date),
         stop_officer_id = row_number())
```

## Ba et al. 2021 Replication - Merging stops to officer assignments

```{r}
# Set the key to make the joining go faster
setkey(stops_dt, officer_id, date)
setkey(assignments_ba_dt, officer_id, date)

# Right join officer shift assignments with stops
stops_merged <- stops_dt[assignments_ba_dt,]
stops_merged[, month := i.month]
stops_merged <- stops_merged[, !"i.month", with = F]

# Drop the stop if it did not occur during the shift
stops_merged <-
    stops_merged[between(hour, floor(start_time), ceiling(end_time)),]

# Deal with stops past midnight on overnight shifts
## Find overnight shifts, fix start and end time, increment date one day forward
assignments_nextday <- assignments_ba_dt[end_time > 24]
assignments_nextday[, new_start_time := 0]
assignments_nextday[, new_end_time := end_time - 24]
assignments_nextday[, date_nextday := date]
day(assignments_nextday$date_nextday) <-
  day(assignments_nextday$date_nextday) + 1
setkey(assignments_nextday, officer_id, date_nextday)

# Right join officer shift assignments with stops
stops_merged_nextday <-
  stops_dt[assignments_nextday,,
           on = c(officer_id = 'officer_id', date = 'date_nextday')]

# Drop the stop if it did not occur during the shift
stops_merged_nextday <-
  stops_merged_nextday[between(hour, floor(new_start_time), ceiling(new_end_time)),]

# Revert back to the normal date
drop_cols <- c("i.date", "new_end_time", "new_start_time", "i.month")
stops_merged_nextday <- stops_merged_nextday[, `:=`(date = i.date, month = i.month)]
stops_merged_nextday <- stops_merged_nextday[, !drop_cols, with = F]

# Merge same-day stops with next-day stops on overnight shifts.
# Then add shift assignments which had no stops.
stops_merged_joined <-
    rbind(stops_merged, stops_merged_nextday) %>%
    full_join(assignments_ba_dt, by = colnames(assignments_ba_dt))

rm(stops_merged, stops_merged_nextday)

a <- stops_merged_joined %>% filter(!(id %in% stops_merged_final$id))
b <- a %>% filter(shift_id %in% stops_merged_final$shift_id)
b2 <- a %>% filter(!(shift_id %in% stops_merged_final$shift_id))
c <- stops_merged_final %>% filter(shift_id %in% b$shift_id) %>% select(shift_id, stop_officer_id, time, start_time, end_time, date)
d <- stops_merged_joined %>% filter(shift_id == "1000921")
```

* Number of resulting stop-shift assignment observations: `r nrow(stops_merged_joined)`
* Number of shift assignments: `r length(unique(stops_merged_joined$shift_id))`
* Number of stop-officer observations: `r length(unique(stops_merged_joined$stop_officer_id))`
    * Percentage of stop-officer observations occurring during an officer's shift: `r 100 * length(unique(stops_merged_joined$stop_officer_id)) / nrow(stops_dt)`%.
* Number of officers who made stops during their shift: `r length(unique(stops_merged_joined$officer_id))`
    * Percentage of officers who made at least one stop during **any** of their shifts: `r 100 * length(unique(stops_merged_joined$officer_id)) / length(unique(assignments_ba_dt$officer_id))`%

## Changing Ba et al. 2021's data cleaning and merging Processes

### Missing Starting and Ending Shift Times

One can compare the same beat assignments during the same days of the week to see how regular shift start times and end times are. Assuming regularity, the start times and end times can be imputed. A more conservative solution would be to just drop all shift assignments which do not have a start time and an end time.

### Duplicate Entries

```{r}
remove_na_dupes <-
    duplicates %>%
    filter(!is.na(start_time) & !is.na(end_time)) %>%
    group_by(stop_officer_id) %>%
    filter(n() > 1) %>%
    ungroup() %>%
    mutate(duplicate = 1)

# Remove duplicate stops to get an accurate count of the number of stops per officer
officer_count_stops <-
    remove_na_dupes %>%
    distinct(stop_officer_id, .keep_all = T) %>%
    count(officer_id)
```
    
**Potential Solutions**  

* One easy fix which immediately comes to mind is to remove all stop-shift assignments where the start time and end time are missing. This doesn't eliminate all duplicates, but it does eliminate most of them. This issue may also be partially fixed upstream when I implement the solution for dealing with missing start times and end times.
    * Number of duplicate stops after removing shift assignments with missing start and end times: `r length(unique(remove_na_dupes$stop_officer_id))` 
    * Percentage reduction after removing shift assignments with a missing start and end time: `r 100 * (length(unique(duplicates$stop_officer_id)) - length(unique(remove_na_dupes$stop_officer_id))) / length(unique(duplicates$stop_officer_id))`%. (Going from `r length(unique(duplicates$stop_officer_id))` to `r length(unique(remove_na_dupes$stop_officer_id))`)
* What should be done about the remaining duplicate entries? Well the stop did occur during both shifts if we are to believe the officer worked on overlapping shifts. It is accurate to say a stop occurred during both shifts. Care will just need to be taken when aggregating the number of stops to an officer across shifts to avoid over counting (i.e. counting the same stop twice).

```{r}
stops_flag <-
    stops_merged_joined %>%
    mutate(stopCount = if_else(is.na(stop_officer_id), 0 , 1))

stops_total <-
    stops_flag %>%
    count(shift_id, wt = stopCount) %>%
    rename(stops_n_total = n)

stops_contact <-
    stops_flag %>%
    count(shift_id, contact_type, wt = stopCount) %>%
    filter(!is.na(contact_type)) %>%
    mutate(contact_type = paste0("stops_n_", contact_type)) %>%
    pivot_wider(id_cols = shift_id,
                names_from = contact_type,
                values_from = n,
                values_fill = 0)

stops_civrace <-
    stops_flag %>%
    count(shift_id, civ.race, wt = stopCount) %>%
    filter(!is.na(civ.race)) %>%
    mutate(civ.race = tolower(civ.race)) %>%
    mutate(civ.race = case_when(civ.race == "asian/pacific islander" ~ "aapi",
                                civ.race == "amer ind/alaskan native" ~ "aian",
                                T ~ civ.race)) %>%
    mutate(civ.race = paste0("stops_n_civilian_", civ.race)) %>%
    pivot_wider(id_cols = shift_id,
                names_from = civ.race,
                values_from = n,
                values_fill = 0)

assignments_outcomes <-
    assignments_ba_dt %>%
    full_join(stops_total, by = "shift_id") %>%
    full_join(stops_civrace, by = "shift_id") %>%
    full_join(stops_contact, by = "shift_id") %>%
    mutate(across(matches("stops_n"), ~replace_na(.x, 0)))

# Read in Ba et al. 2021 pure replication
ba_assignments_outcomes <-
    read_csv(here("0-clean-data", "output", "stops-outcomes_ba.csv")) %>%
    filter(is.na(stops_n_total))

write_csv(stops_merged_joined,
          here("0-clean-data", "output", "stops-assignments_ba-joe.csv"))

write_csv(assignments_outcomes,
          here("0-clean-data", "output", "stops-outcomes_ba-joe.csv"))
```

* **NOTE**: There are `r nrow(ba_assignments_outcomes)` shift assignments which have missing values for the number of stops. In the original Ba et al. 2021 paper, these shift assignments had stops which took place during the same day of the shift but did not occur during the actual shift. It's unclear why Ba et al. 2021 consider these shift assignments as **missing** the number of stops rather than having **zero** stops. In any case, I consider these shift assignments to have zero stops.
    * Percentage of shift assignments missing the number of stops: `r 100 * nrow(ba_assignments_outcomes) / nrow(assignments_ba_dt)`%.
